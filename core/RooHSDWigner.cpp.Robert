#include "RooHSDWigner.h"

#include "TError.h"

namespace HS{
  namespace FIT{


    RooHSDWigner::RooHSDWigner(const char* name, const char* title, RooAbsReal& theta, RooAbsReal& phi, int l, int m, int s,Double_t factor)
      : RooHSComplex(name, title)
      ,_theta("theta", "theta", this,theta)
      ,_phi("phi", "phi", this,phi)
      ,_sqt(2*l+1)
      ,_dmatrix(l+1,arr(2*l+1)) 
      ,_L(l),_M(m),_S(s)
      ,_n(-1)
    {
      for (size_t index=0; index<_sqt.size(); ++index) _sqt[index] = TMath::Sqrt(double(index));

      std::cout<<"1*********&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& "<<_dmatrix.size()<<std::endl;
      std::cout<<"2*********&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& "<<_dmatrix[0].size()<<std::endl;
 
    }


 ////////////////////////////////////////////////////////////////////////////////

    RooHSDWigner::RooHSDWigner(const RooHSDWigner& other, const char* name)
      : RooHSComplex(other, name),
	_theta("theta", this, other._theta),
	_phi("phi", this, other._phi),
	//_sqt(other._L * 2 + 1),
	//_dmatrix(other._L  + 1,arr(other._L * 2 + 1)), 
	_sqt(other._sqt),
	_dmatrix(other._dmatrix), 
	_L(other._L), _M(other._M), _S(other._S), _n(other._n)
    {
      // if(_M%2==1)_MFactor=-1;
      //else _MFactor =1;
      //_MFactor =1;
      // _N=other._N;


      std::cout<<"1&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& "<<_dmatrix.size()<<std::endl;
      std::cout<<"2&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&& "<<_dmatrix[0].size()<<std::endl;
    }


    ////////////////////////////////////////////////////////////
 void RooHSDWigner::do_line0 (arr &l1, int j) const
   {
   double xj = 1./j;
   l1[j] = -_p*l1[j-1];
   for (int i=j-1; i>=1; --i)
     l1[i] = xj*_sqt[j]*(_q*_sqt[j-i]*l1[i] - _p*_sqt[i]*l1[i-1]);
   l1[0] = _q*l1[0];
   }


    // void RooHSDWigner::do_line (const double *l1, double *l2, int j, int k) const
 void RooHSDWigner::do_line (const arr &l1, arr &l2, int j, int k) const
   {
   double xj = 1./j;
   double t1 = xj*_sqt[j-k]*_q, t2 = xj*_sqt[j-k]*_p;
   double t3 = xj*_sqt[k]*_p,   t4 = xj*_sqt[k]*_q;
   l2[j] = _sqt[j] * (t4*l1[j-1]-t2*l2[j-1]);
   for (int i=j-1; i>=1; --i)
     l2[i] = t1*_sqt[j-i]*l2[i] - t2*_sqt[i]*l2[i-1]
             +t3*_sqt[j-i]*l1[i] + t4*_sqt[i]*l1[i-1];
   l2[0] = _sqt[j] * (t3*l1[0]+t1*l2[0]);
   }
   /////////////////////////////////////////////////////////////////////////

    /*arr2<double>*/ void RooHSDWigner::recurse() const
   {
   ++_n;
   if (_n==0)
     _dmatrix[0][0] = 1;
   else if (_n==1)
     {
     _dmatrix[0][0] = _q*_q; 
     _dmatrix[0][1] = -_p*_q*_sqt[2]; 
     _dmatrix[0][2] = _p*_p;
     _dmatrix[1][0] = -_dmatrix[0][1]; 
     _dmatrix[1][1] = _q*_q-_p*_p; 
     _dmatrix[1][2] = _dmatrix[0][1];
     }
   else
     {
     int sign = (_n&1)? -1 : 1;
     for (int i=0; i<=2*_n-2; ++i)
       {
       _dmatrix[_n][i] = sign*_dmatrix[_n-2][2*_n-2-i];
       sign=-sign;
       }
     do_line (_dmatrix[_n-1],_dmatrix[_n],2*_n-1,_n);
     for (int k=_n; k>=2; --k)
       {
       do_line (_dmatrix[k-2],_dmatrix[k-1],2*_n-1,k-1);
       do_line (_dmatrix[k-1],_dmatrix[k],2*_n,k);
       }
     do_line0 (_dmatrix[0],2*_n-1);
     do_line (_dmatrix[0],_dmatrix[1],2*_n,1);
     do_line0 (_dmatrix[0],2*_n);
     }
   //  return d;
   }




double RooHSDWigner::SmallWignerD( int aj, int am, int an, double beta ) const{
  
  // Calculates the beta-term
  //                         d j mn (beta)
  // in the matrix element of the finite rotation operator
  // (Wigner's D-function), according to formula 4.3.1(3) in
  // D.A. Varshalovich, A.N. Moskalev, and V.K. Khersonskii,
  // Quantum Theory of Angular Momentum, World Scientific,
  // Singapore 1988.
  // CERNLIB DDJMNB function translated from Fortran to C++ by Rene Brun
  
  //double f = 8.72664625997164788e-3; //  M_PI/360
  
  double fcl[51] = { 0 , 0 ,
    6.93147180559945309e-1 ,1.79175946922805500e00,
    3.17805383034794562e00 ,4.78749174278204599e00,
    6.57925121201010100e00 ,8.52516136106541430e00,
    1.06046029027452502e01 ,1.28018274800814696e01,
    1.51044125730755153e01 ,1.75023078458738858e01,
    1.99872144956618861e01 ,2.25521638531234229e01,
    2.51912211827386815e01 ,2.78992713838408916e01,
    3.06718601060806728e01 ,3.35050734501368889e01,
    3.63954452080330536e01 ,3.93398841871994940e01,
    4.23356164607534850e01 ,4.53801388984769080e01,
    4.84711813518352239e01 ,5.16066755677643736e01,
    5.47847293981123192e01 ,5.80036052229805199e01,
    6.12617017610020020e01 ,6.45575386270063311e01,
    6.78897431371815350e01 ,7.12570389671680090e01,
    7.46582363488301644e01 ,7.80922235533153106e01,
    8.15579594561150372e01 ,8.50544670175815174e01,
    8.85808275421976788e01 ,9.21361756036870925e01,
    9.57196945421432025e01 ,9.93306124547874269e01,
    1.02968198614513813e02 ,1.06631760260643459e02,
    1.10320639714757395e02 ,1.14034211781461703e02,
    1.17771881399745072e02 ,1.21533081515438634e02,
    1.25317271149356895e02 ,1.29123933639127215e02,
    1.32952575035616310e02 ,1.36802722637326368e02,
    1.40673923648234259e02 ,1.44565743946344886e02,
    1.48477766951773032e02};
  
  int jpm = int(aj+am);
  int jpn = int(aj+an);
  int jmm = int(aj-am);
  
  int jmn = int(aj-an);
  int mpn = int(am+an);
  
  double r = 0;
  if (beta == 0)
  {
    if (jpm == jpn) r = 1;
  }
  else if (beta == M_PI)
  {
    if (jpm == jmn)
    {
      r = 1;
      if ( (jpm > 0 ? jpm : -jpm ) % 2 == 1 ) r = -1;
    }
  }
  else if (beta == 2.*M_PI)
  {
    if (jpm == jpn)
    {
      r = 1;
      if ( (jpm > 0 ? jpm : -jpm ) % 2 == 1 ) r = -1;
    }
  }
  else
  {
    double b  = beta/2.; //f*beta;
    double s  = log(sin(b));
    double c  = log(fabs(cos(b)));
    double rt = 0.5*(fcl[jpm]+fcl[jmm]+fcl[jpn]+fcl[jmn]);
    int k0    = ( 0 > mpn ? 0 : mpn ); //max( 0 , mpn )
    int kq    = k0+jpm;
    if (beta > 180) kq += mpn;
    double q  = 1;
    if (kq%2 == 1) q = -1;
    kq = k0+k0;
    double cx = kq-mpn;
    double sx = jpm+jpn-kq;
    for( int k = k0 ; k <= ( jpm < jpn ? jpm : jpn ); k++ )
    {
      r  += q*exp(rt-fcl[k]-fcl[jpm-k]-fcl[jpn-k]-fcl[k-mpn]+ cx*c+sx*s);
      cx += 2;
      sx -= 2;
      q   = -q;
    }
  }
  
  return r;
}

 

  ////////////////////////////////////////////////////////////////////////////////

    RooHSDWignerRe::RooHSDWignerRe(const char *name, const char *title, RooAbsReal& theta, RooAbsReal& phi, RooAbsReal& dwigner )
      :  RooAbsReal(name, title),
	 _theta("Theta","Theta",this,theta),
	 _phi("Phi","Phi",this,phi),
	 _mag("Mag","Mag",this,dwigner)
    {
      auto mag=dynamic_cast<RooHSDWigner*>(&dwigner);
      _M=mag->M();
    }

  ////////////////////////////////////////////////////////////////////////////////
    RooHSDWignerRe::RooHSDWignerRe(const RooHSDWignerRe& other, const char* name)
      : RooAbsReal(other, name),
	_theta("Theta", this, other._theta),
	_phi("Phi", this, other._phi),
	_mag("Mag", this, other._mag),
	_M(other._M)
    {
   
    }


 ////////////////////////////////////////////////////////////////////////////////

    RooHSDWignerIm::RooHSDWignerIm(const char *name, const char *title, RooAbsReal& theta, RooAbsReal& phi, RooAbsReal& dwigner,Int_t conj)
      :  RooAbsReal(name, title),
	 _theta("Theta","Theta",this,theta),
	 _phi("Phi","Phi",this,phi),
	 _mag("Mag","Mag",this,dwigner),
	 _conj(conj)
    {
      auto mag=dynamic_cast<RooHSDWigner*>(&dwigner);
      _M=mag->M();
    }

  ////////////////////////////////////////////////////////////////////////////////
    RooHSDWignerIm::RooHSDWignerIm(const RooHSDWignerIm& other, const char* name)
      : RooAbsReal(other, name),
	_theta("Theta", this, other._theta),
	_phi("Phi", this, other._phi),
	_mag("Mag", this, other._mag),
	_M(other._M),
	_conj(other._conj)
    {
   
    }
  
  }//FIT
}//HS
